// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: query.sql

package querytest

import (
	"context"
	"database/sql"
)

const duplicate = `-- name: Duplicate :one
SELECT users.id, users.name, users.age, users.id, users.name, users.age FROM users
`

type DuplicateRow struct {
	Users   interface{}
	Users_2 interface{}
}

func (q *Queries) Duplicate(ctx context.Context) (DuplicateRow, error) {
	row := q.db.QueryRowContext(ctx, duplicate)
	var i DuplicateRow
	err := row.Scan(&i.Users, &i.Users_2)
	return i, err
}

const join = `-- name: Join :one
SELECT u.id, u.name, u.age, p.id, p.user_id FROM posts AS p
INNER JOIN users AS u ON p.user_id = u.users.id
`

type JoinRow struct {
	Users interface{}
	Posts interface{}
}

func (q *Queries) Join(ctx context.Context) (JoinRow, error) {
	row := q.db.QueryRowContext(ctx, join)
	var i JoinRow
	err := row.Scan(&i.Users, &i.Posts)
	return i, err
}

const only = `-- name: Only :one
SELECT users.id, users.name, users.age FROM users
`

type OnlyRow struct {
	Users interface{}
}

func (q *Queries) Only(ctx context.Context) (OnlyRow, error) {
	row := q.db.QueryRowContext(ctx, only)
	var i OnlyRow
	err := row.Scan(&i.Users)
	return i, err
}

const withAlias = `-- name: WithAlias :one
SELECT u.id, u.name, u.age FROM users AS u
`

type WithAliasRow struct {
	Users interface{}
}

func (q *Queries) WithAlias(ctx context.Context) (WithAliasRow, error) {
	row := q.db.QueryRowContext(ctx, withAlias)
	var i WithAliasRow
	err := row.Scan(&i.Users)
	return i, err
}

const withAsterisk = `-- name: WithAsterisk :one
SELECT users.id, users.name, users.age, id, name, age FROM users
`

type WithAsteriskRow struct {
	Users interface{}
	ID    int64
	Name  string
	Age   sql.NullInt64
}

func (q *Queries) WithAsterisk(ctx context.Context) (WithAsteriskRow, error) {
	row := q.db.QueryRowContext(ctx, withAsterisk)
	var i WithAsteriskRow
	err := row.Scan(
		&i.Users,
		&i.ID,
		&i.Name,
		&i.Age,
	)
	return i, err
}

const withSubquery = `-- name: WithSubquery :many
SELECT users.id, users.name, users.age, (SELECT count(*) FROM users) AS total_count FROM users
`

type WithSubqueryRow struct {
	Users      interface{}
	TotalCount int64
}

func (q *Queries) WithSubquery(ctx context.Context) ([]WithSubqueryRow, error) {
	rows, err := q.db.QueryContext(ctx, withSubquery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WithSubqueryRow
	for rows.Next() {
		var i WithSubqueryRow
		if err := rows.Scan(&i.Users, &i.TotalCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
