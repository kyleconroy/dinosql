{{define "batchCodePgx"}}
{{range .GoQueries}}
{{if eq (hasPrefix .Cmd ":batch") true }}
const {{.ConstantName}} = {{$.Q}}-- name: {{.MethodName}} {{.Cmd}}
{{escape .SQL}}
{{$.Q}}

type {{.MethodName}}BatchResults struct {
    br pgx.BatchResults
}

{{if .Arg.EmitStruct}}
type {{.Arg.Type}} struct { {{- range .Arg.Struct.Fields}}
  {{.Name}} {{.Type}} {{if or ($.EmitJSONTags) ($.EmitDBTags)}}{{$.Q}}{{.Tag}}{{$.Q}}{{end}}
  {{- end}}
}
{{end}}

{{if .Ret.EmitStruct}}
type {{.Ret.Type}} struct { {{- range .Ret.Struct.Fields}}
  {{.Name}} {{.Type}} {{if or ($.EmitJSONTags) ($.EmitDBTags)}}{{$.Q}}{{.Tag}}{{$.Q}}{{end}}
  {{- end}}
}
{{end}}

{{if eq .Cmd ":batchexec"}}
{{range .Comments}}//{{.}}
{{end -}}
func (q *Queries) {{.MethodName}}(ctx context.Context, {{- if $.EmitMethodsWithDBArgument}}db DBTX,{{end}} {{.Arg.SlicePair}}) *{{.MethodName}}BatchResults {
    batch := &pgx.Batch{}
    for _, a := range {{index .Arg.Name}} {
        vals := []interface{}{
        {{- if .Arg.Struct }}
        {{- range .Arg.Struct.Fields }}
            a.{{.Name}},
        {{- end }}
        {{- else }}
            a,
        {{- end }}
        }
        batch.Queue({{.ConstantName}}, vals...)
    }
    br := {{if not $.EmitMethodsWithDBArgument}}q.{{end}}db.SendBatch(ctx, batch)
    return &{{.MethodName}}BatchResults{br}
}

func (b *{{.MethodName}}BatchResults) Exec(f func(error)) {
    for {
		_, err := b.br.Exec()
        if err != nil && err.Error() == "no result" {
			break
		}
        if f != nil {
            f(err)
        }
	}
}
{{end}}

func (b *{{.MethodName}}BatchResults) Close() error {
    return b.br.Close()
}
{{end}}
{{end}}
{{end}}
