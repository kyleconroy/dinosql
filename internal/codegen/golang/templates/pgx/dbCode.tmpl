{{define "dbCodeTemplatePgx"}}

type DBTX interface {
	Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
	Query(context.Context, string, ...interface{}) (pgx.Rows, error)
	QueryRow(context.Context, string, ...interface{}) pgx.Row
{{- if .UsesCopyFrom }}
	CopyFrom(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (int64, error)
{{- end }}
{{- if .UsesBatch }}
	SendBatch(context.Context, *pgx.Batch) pgx.BatchResults
{{- end }}
}

{{ if .EmitMethodsWithDBArgument}}
func New() *Queries {
	return &Queries{observer: noopObserver}
{{- else -}}
func New(db DBTX) *Queries {
	return &Queries{db: db, observer: noopObserver}
{{- end}}
}

type Queries struct {
    {{if not .EmitMethodsWithDBArgument}}
	db DBTX
    {{end}}
    observer func(ctx context.Context, methodName string) (context.Context, func(err error) error)
}

func noopObserver(ctx context.Context, methodName string) (context.Context, func(err error) error) {
	return ctx, func(err error) error { return err }
}

// WithObserver can be used to observe queries (metric, log, trace, ...)
// Example usage:
// 	queries.WithObserver(func (ctx context.Context, methodName string) (context.Context, func(err error) error) {
// 		spanCtx, span := tracer.Start(ctx, methodName)
// 		startTime := time.New()
// 		return spanCtx, func(err error) error {
// 			log.Println("Query %q executed in %s", methodName, time.Since(startTime))
// 			span.End()
// 			return err
// 		}
// 	})
func (q *Queries) WithObserver(observer func(ctx context.Context, methodName string) (context.Context, func(err error) error)) *Queries {
	return &Queries{
		{{if not .EmitMethodsWithDBArgument}}
		db: q.db,
		{{end}}
		observer: observer,
	}
}

{{if not .EmitMethodsWithDBArgument}}
func (q *Queries) WithTx(tx pgx.Tx) *Queries {
	return &Queries{
		db: tx,
		observer: q.observer,
	}
}
{{end}}
{{end}}

