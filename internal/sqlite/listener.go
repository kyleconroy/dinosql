package sqlite

import (
	"fmt"

	"github.com/kyleconroy/sqlc/internal/sql/ast"
	"github.com/kyleconroy/sqlc/internal/sqlite/parser"
)

type listener struct {
	*parser.BaseSQLiteListener

	stmt *ast.RawStmt

	stmts []ast.Statement
}

// The Visitor code generated by Antlr doesn't currently work
//
// To make due, we mark the listener as "busy" if it's currently processing a
// node. This helps avoids scenarios where enter is called on nested
// statements.
func (l *listener) busy() bool {
	return l.stmt != nil
}

func (l *listener) EnterSql_stmt(c *parser.Sql_stmtContext) {
	fmt.Printf("%#v", c)
	l.stmt = nil
}

func (l *listener) ExitSql_stmt(c *parser.Sql_stmtContext) {
	if l.stmt != nil {
		l.stmts = append(l.stmts, ast.Statement{
			Raw: l.stmt,
		})
	}
}

func (l *listener) EnterCreate_table_stmt(c *parser.Create_table_stmtContext) {
	if l.busy() {
		return
	}

	name := ast.TableName{
		Name: c.Table_name().GetText(),
	}

	if c.Database_name() != nil {
		name.Schema = c.Database_name().GetText()
	}

	stmt := &ast.CreateTableStmt{
		Name:        &name,
		IfNotExists: c.K_EXISTS() != nil,
	}

	for _, idef := range c.AllColumn_def() {
		if def, ok := idef.(*parser.Column_defContext); ok {
			stmt.Cols = append(stmt.Cols, &ast.ColumnDef{
				Colname: def.Column_name().GetText(),
				TypeName: &ast.TypeName{
					Name: def.Type_name().GetText(),
				},
			})
		}
	}

	l.stmt = &ast.RawStmt{Stmt: stmt}
}

func (l *listener) EnterDrop_table_stmt(c *parser.Drop_table_stmtContext) {
	if l.busy() {
		return
	}

	drop := &ast.DropTableStmt{
		IfExists: c.K_EXISTS() != nil,
	}

	name := ast.TableName{
		Name: c.Table_name().GetText(),
	}

	if c.Database_name() != nil {
		name.Schema = c.Database_name().GetText()
	}

	drop.Tables = append(drop.Tables, &name)
	l.stmt = &ast.RawStmt{Stmt: drop}
}

func (l *listener) EnterSelect_stmt(c *parser.Select_stmtContext) {
	panic("EnterSelect_stmt")

	if l.busy() {
		return
	}

	sel := &ast.SelectStmt{}
	l.stmt = &ast.RawStmt{Stmt: sel}
}

func (l *listener) EnterSimple_select_stmt(c *parser.Simple_select_stmtContext) {
	panic("EnterSimple_select_stmt")

	if l.busy() {
		return
	}

	sel := &ast.SelectStmt{}
	l.stmt = &ast.RawStmt{Stmt: sel}
}
