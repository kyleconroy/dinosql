// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: query.sql

package update

import (
	"context"
	"database/sql"
)

const createT1 = `-- name: CreateT1 :execresult
INSERT INTO
  t1 (user_id, name)
VALUES
  (?, ?)
`

type CreateT1Params struct {
	UserID int32
	Name   string
}

func (q *Queries) CreateT1(ctx context.Context, arg CreateT1Params) (sql.Result, error) {
	return q.db.ExecContext(ctx, createT1, arg.UserID, arg.Name)
}

const createT2 = `-- name: CreateT2 :execresult
INSERT INTO
  t2 (email, name)
VALUES
  (?, ?)
`

type CreateT2Params struct {
	Email string
	Name  string
}

func (q *Queries) CreateT2(ctx context.Context, arg CreateT2Params) (sql.Result, error) {
	return q.db.ExecContext(ctx, createT2, arg.Email, arg.Name)
}

const createT3 = `-- name: CreateT3 :execresult
INSERT INTO
  t3 (user_id, email)
VALUES
  (?, ?)
`

type CreateT3Params struct {
	UserID int32
	Email  string
}

func (q *Queries) CreateT3(ctx context.Context, arg CreateT3Params) (sql.Result, error) {
	return q.db.ExecContext(ctx, createT3, arg.UserID, arg.Email)
}

const getT1 = `-- name: GetT1 :one
SELECT
  user_id, name
FROM
  t1
WHERE
  user_id = ?
LIMIT
  1
`

func (q *Queries) GetT1(ctx context.Context, userID int32) (T1, error) {
	row := q.db.QueryRowContext(ctx, getT1, userID)
	var i T1
	err := row.Scan(&i.UserID, &i.Name)
	return i, err
}

const updateAll = `-- name: UpdateAll :exec
UPDATE
  t1
  INNER JOIN t3 ON t3.user_id = t1.user_id
  INNER JOIN t2 ON t2.email = t3.email
SET
  t1.name = t2.name
WHERE
  t1.name = ''
`

func (q *Queries) UpdateAll(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, updateAll)
	return err
}
